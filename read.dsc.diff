diff --git a/NAMESPACE b/NAMESPACE
index b5b39cb..6d68a57 100644
--- a/NAMESPACE
+++ b/NAMESPACE
@@ -85,6 +85,7 @@ export(
   "bn.moments",
   "read.bif",
   "write.bif",
+  "read.dsc",
   "write.dsc",
   "write.net"
 )
diff --git a/R/foreign.R b/R/foreign.R
index 7fd1de7..3b3c114 100644
--- a/R/foreign.R
+++ b/R/foreign.R
@@ -1,6 +1,6 @@
 
 # read a BIF file into a bn.fit object.
-read.bif.backend = function(lines, debug = FALSE) {
+read.bif.backend = function(lines, dsc = FALSE, debug = FALSE) {
 
   nlines = length(lines)
 
@@ -11,19 +11,41 @@ read.bif.backend = function(lines, debug = FALSE) {
   # remove empty lines.
   lines = lines[grep("^\\s*$", lines, perl = TRUE, invert = TRUE)]
 
-  if (grep("^network", lines[1]) != 1)
-    stop("the file '", file, "' does not conform to the BIF standard.")
+  # check the file banner.
+  if (dsc) {
+
+    if (length(grep("^belief network", lines[1])) != 1)
+      stop("the file does not conform to the DSC standard.")
+
+  }#THEN
+  else {
+
+    if (length(grep("^network", lines[1])) != 1)
+      stop("the file does not conform to the BIF standard.")
+
+  }#ELSE
 
   # get the node labels.
-  nodes = sub("variable\\s+(.+)\\s+\\{", "\\1", 
-            grep("^variable .+", lines, value = TRUE), perl = TRUE)
+  if (dsc) {
+
+    nodes = sub("node\\s+([^\\s\\{]+)\\s*\\{*", "\\1", 
+              grep("^node .+", lines, value = TRUE), perl = TRUE)
+
+  }#THEN
+  else {
+
+    nodes = sub("variable\\s+([^\\s\\{]+)\\s*\\{*", "\\1", 
+              grep("^variable .+", lines, value = TRUE), perl = TRUE)
+
+  }#ELSE
+
   nnodes = length(nodes)
 
   # check whether all variables are discrete.
-  if (length(grep("type discrete", lines)) != nnodes)
+  if (length(grep("type\\s*[:]{0,1}\\s*discrete", lines)) != nnodes)
     stop("only BIF files describing discrete networks are supported.")
   # check whether the labels on the probability tables match with the node labels.
-  cpts =  sub("probability\\s+\\(\\s+(.+?)\\s+.+", "\\1",
+  cpts =  sub("probability\\s+\\(\\s*(\\w+).*", "\\1",
             grep("^probability", lines, value = TRUE))
 
   if (!setequal(cpts, nodes)) {
@@ -32,10 +54,10 @@ read.bif.backend = function(lines, debug = FALSE) {
     missing.nodes = setdiff(cpts, nodes)
     bogus = unique(c(missing.cpts, missing.nodes))
 
-    for (m in  missing.cpts)
+    for (m in missing.cpts)
       warning("the CPT corresponding to node ", m, " is missing, dropping.")
 
-    for (m in  missing.nodes)
+    for (m in missing.nodes)
       warning("the node description of node ", m, " is missing, dropping.")
 
     # recompute fundamental quantities.
@@ -53,7 +75,7 @@ read.bif.backend = function(lines, debug = FALSE) {
   description.start = .Call("match_descriptions",
                             lines = lines,
                             nodes = nodes,
-                            string = "variable",
+                            string = ifelse(dsc, "node", "variable"),
                             PACKAGE = "bnlearn");
 
   # find out where each conditional probability table begins.
@@ -101,7 +123,7 @@ read.bif.backend = function(lines, debug = FALSE) {
     # built the probability table.
     node.cpt = bif.get.probabilities(node, start = cpt.start, lines = lines,
                  nodes.levels = nodes.levels, parents = parents,
-                 root = (node %in% root.nodes))
+                 root = (node %in% root.nodes), dsc = dsc)
 
     # get the parent set.
     if (node %in% root.nodes)
@@ -110,8 +132,8 @@ read.bif.backend = function(lines, debug = FALSE) {
       parent.set = parents[[node]]
 
     fitted[[node]] = structure(list(node = node, parents = parent.set,
-                       children = bif.get.children(node, parents), prob = node.cpt),
-                       class = "bn.fit.dnode")
+                       children = bif.get.children(node, parents),
+                       prob = node.cpt), class = "bn.fit.dnode")
 
     if (debug) {
 
@@ -144,7 +166,7 @@ bif.get.parents = function(lines, start, dummies, bogus) {
   # get the dependencies.
   parents = (lines[start])[grep("\\|", lines[start])]
   # extract the node labels and the labels of the respective parents.
-  parents = sub("probability\\s+\\(\\s+(.+)\\s+\\|(.+)\\)\\s+\\{", "\\1 \\2",
+  parents = sub("probability\\s+\\(\\s*(.+)\\s*\\|\\s*(.+)\\)", "\\1 \\2",
                parents)
   # split the labels of the parents.
   nonroot.nodes = sapply(strsplit(parents, " "), "[", 1)
@@ -191,15 +213,16 @@ bif.get.levels = function(node, start, lines) {
   # get all the node's description on one line for easy handling.
   desc = paste(lines[start.line:end.line], collapse = "")
   # deparse the node's level.
-  levels = sub(".+type\\s+discrete\\s*\\[\\s*\\d+\\s*\\]\\s+[=]*\\s*\\{\\s+(.+)\\s*\\}.+", "\\1", desc)
+  levels = sub(".+type\\s+[:]{0,1}\\s*discrete\\s*\\[\\s*\\d+\\s*\\]\\s+[=]{0,1}\\s*\\{\\s*(.+)\\s*\\}.+", "\\1", desc)
   levels = strsplit(levels, ",")[[1]]
-  levels = sub("^\\s*(.+?)\\s*$", "\\1", levels)
+  levels = sub("^\\s*\"*(.+?)\"*\\s*$", "\\1", levels)
 
   return(levels)
 
 }#BIF.GET.LEVELS
 
-bif.get.probabilities = function(node, start, lines, nodes.levels, parents, root) {
+bif.get.probabilities = function(node, start, lines, nodes.levels, parents, 
+    root, dsc) {
 
   end.line = 0
 
@@ -217,7 +240,11 @@ bif.get.probabilities = function(node, start, lines, nodes.levels, parents, root
   # deparse the node's probability table.
   if (root) {
 
-    probs = sub(".+table\\s+(.+)\\s*;\\s*\\}.*", "\\1", desc)
+    if (dsc)
+      probs = sub(".+\\{\\s*(.+)\\s*;\\s*\\}.*", "\\1", desc)
+    else
+      probs = sub(".+table\\s+(.+)\\s*;\\s*\\}.*", "\\1", desc)
+
     probs = strsplit(probs, ",")[[1]]
 
     if (length(probs) != length(nodes.levels[[node]]))
@@ -231,12 +258,35 @@ bif.get.probabilities = function(node, start, lines, nodes.levels, parents, root
   else {
 
     row = strsplit(sub(".+\\{[^(]*(\\(.+?)\\s*[;]*\\s*\\}.*", "\\1", desc), ";")[[1]]
-    cfg = strsplit(sub(".*\\((.+)\\).+", "\\1", row), ",")
-    cfg = lapply(cfg, sub, pattern = "^\\s*(.+?)\\s*$", replacement = "\\1")
-    probs = strsplit(sub(".*\\)\\s*(.+)", "\\1", row), ",")
+
+    # extract the conditional probability distributions.
+    probs = strsplit(sub(".*\\)\\s*[:]{0,1}\\s*(.+)", "\\1", row), ",")
     probs = lapply(probs, as.numeric)
     dims = lapply(c(node, parents[[node]]), function(x) nodes.levels[[x]])
 
+    # extract the configurations of the parents.
+    cfg = strsplit(sub(".*\\((.+)\\).+", "\\1", row), ",")
+    cfg = lapply(cfg, sub, pattern = "^\\s*(.+?)\\s*$", replacement = "\\1")
+
+    # DSC files use numeric coordinates instead of levels.
+    if (dsc) {
+
+      if (all(sapply(cfg, function(x) all(x == 0)))) {
+
+        cfg = lapply(dims, function(x) seq(length(x)))
+        cfg = expand.grid(cfg[1+rev(1:length(parents[[node]]))])
+        cfg = cfg[rev(1:ncol(cfg))]
+        cfg = lapply(seq(nrow(cfg)), function(x) cfg[x, ])
+
+      }#THEN
+      else {
+
+        cfg = lapply(cfg, function(x) as.numeric(x) + 1)
+
+      }#ELSE
+
+    }#THEN
+
     # check whether the number of conditional probability distributions matches
     # the number of configurations.
     if (length(probs) != length(cfg))
diff --git a/R/frontend-foreign.R b/R/frontend-foreign.R
index 7a14dce..0292e97 100644
--- a/R/frontend-foreign.R
+++ b/R/frontend-foreign.R
@@ -5,7 +5,7 @@ read.bif = function(file, debug = FALSE) {
   # load the BIF file into memory.
   lines = readLines(file)  
 
-  read.bif.backend(lines, debug = debug)
+  read.bif.backend(lines, dsc = FALSE, debug = debug)
 
 }#READ.BIF
 
@@ -29,6 +29,16 @@ write.bif = function(file, fitted) {
 
 }#WRITE.BIF
 
+# read a BIF file into a bn.fit object.
+read.dsc = function(file, debug = FALSE) {
+
+  # load the DSC file into memory.
+  lines = readLines(file)
+
+  read.bif.backend(lines, dsc = TRUE, debug = debug)
+
+}#READ.DSC
+
 # dump a bn.fit object into a DSC file.
 write.dsc = function(file, fitted) {
 
